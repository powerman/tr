// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny


package app

import (
	"sync"

	"github.com/vugu/vugu"
)

type (
	// TopicRecordAdded manages subscription on EventRecordAdded.
	// While filtering can be implemented inside OnRecordAdded method,
	// using filters may increase performance because filters will be
	// called without locked EventEnv. Subscriber will get an event if
	// there are no filters provided or ANY of given filters match.
	TopicRecordAdded interface {
		SubscribeRecordAdded(c OnRecordAdded, ee EventEnver, filters ...filterRecordAdded)
		UnsubscribeRecordAdded(c OnRecordAdded)
	}
	// OnRecordAdded must be implemented by EventRecordAdded subscribers.
	// It'll be called with locked EventEnv.
	OnRecordAdded interface {
		OnRecordAdded(EventRecordAdded) bool // Return true to request re-render.
	}
	// FilterRecordAdded is not exported to make it easier to ensure
	// all filters are safe to call without locked EventEnv by
	// implementing all filters in app package.
	// TODO Add custom linter to ensure filters won't get ref in args?
	filterRecordAdded func(EventRecordAdded) bool
	// topicRecordAdded provides a way to broadcast EventRecordAdded to any
	// amount of subscribers.
	//
	// It subscribe/unsubscribe/emit methods are guaranteed to not
	// block and thus safe to call everywhere.
	//
	// Ref to zero value is ready to use topic.
	topicRecordAdded struct {
		mu          sync.Mutex
		queue       []EventRecordAdded
		subs        map[OnRecordAdded]*subscriptionRecordAdded
		broadcastMu sync.Mutex
	}
	subscriptionRecordAdded struct {
		c       OnRecordAdded
		ee      vugu.EventEnv
		filters []filterRecordAdded
	}
)

// SubscribeRecordAdded adds or replaces c subscription to the topic using
// given filters. Provided ee is locked before calling c.OnRecordAdded and
// unlocked (with render, if it'll return true) when it returns.
func (t *topicRecordAdded) SubscribeRecordAdded(c OnRecordAdded, ee EventEnver, filters ...filterRecordAdded) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.subs == nil {
		t.subs = make(map[OnRecordAdded]*subscriptionRecordAdded)
	}
	t.subs[c] = &subscriptionRecordAdded{
		c:       c,
		ee:      ee.EventEnv(),
		filters: filters,
	}
}

// UnsubscribeRecordAdded unsubscribes c from the topic.
func (t *topicRecordAdded) UnsubscribeRecordAdded(c OnRecordAdded) {
	t.mu.Lock()
	defer t.mu.Unlock()
	delete(t.subs, c)
}

// EmitRecordAdded sends ev to all subscribers whose filters accepts it.
// It isn't exported because only app should be able to emit such events.
func (t *topicRecordAdded) emitRecordAdded(ev EventRecordAdded) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.queue = append(t.queue, ev)
	go t.broadcastOne()
}

func (t *topicRecordAdded) broadcastOne() {
	t.broadcastMu.Lock()
	defer t.broadcastMu.Unlock()

	t.mu.Lock()
	var ev EventRecordAdded
	ev, t.queue = t.queue[0], t.queue[1:]
	subs := make([]*subscriptionRecordAdded, 0, len(t.subs))
	for c := range t.subs {
		subs = append(subs, t.subs[c])
	}
	t.mu.Unlock()

	for _, s := range subs {
		pass := len(s.filters) == 0
		for i := 0; !pass && i < len(s.filters); i++ {
			pass = s.filters[i](ev)
		}
		if pass {
			s.ee.Lock()
			if s.c.OnRecordAdded(ev) {
				s.ee.UnlockRender()
			} else {
				s.ee.UnlockOnly()
			}
		}
	}
}

// FilterRecordAddedAnd returns true if all filters returns true or no filters
// given.
func FilterRecordAddedAnd(filters ...filterRecordAdded) filterRecordAdded {
	return func(ev EventRecordAdded) bool {
		for _, filter := range filters {
			if !filter(ev) {
				return false
			}
		}
		return true
	}
}
